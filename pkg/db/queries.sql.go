// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const addTeamMember = `-- name: AddTeamMember :one
INSERT INTO team_members (team_id, user_id, role)
VALUES ($1, $2, $3)
RETURNING team_id, user_id, role
`

type AddTeamMemberParams struct {
	TeamID int32  `json:"team_id"`
	UserID int32  `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) (TeamMember, error) {
	row := q.db.QueryRowContext(ctx, addTeamMember, arg.TeamID, arg.UserID, arg.Role)
	var i TeamMember
	err := row.Scan(&i.TeamID, &i.UserID, &i.Role)
	return i, err
}

const createActivityFeedEntry = `-- name: CreateActivityFeedEntry :one
INSERT INTO activity_feed (actor_id, action, target_type, target_id, org_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, actor_id, action, target_type, target_id, org_id, created_at
`

type CreateActivityFeedEntryParams struct {
	ActorID    sql.NullInt32  `json:"actor_id"`
	Action     string         `json:"action"`
	TargetType sql.NullString `json:"target_type"`
	TargetID   sql.NullInt32  `json:"target_id"`
	OrgID      sql.NullInt32  `json:"org_id"`
}

func (q *Queries) CreateActivityFeedEntry(ctx context.Context, arg CreateActivityFeedEntryParams) (ActivityFeed, error) {
	row := q.db.QueryRowContext(ctx, createActivityFeedEntry,
		arg.ActorID,
		arg.Action,
		arg.TargetType,
		arg.TargetID,
		arg.OrgID,
	)
	var i ActivityFeed
	err := row.Scan(
		&i.ID,
		&i.ActorID,
		&i.Action,
		&i.TargetType,
		&i.TargetID,
		&i.OrgID,
		&i.CreatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (sender_id, recipient_id, content)
VALUES ($1, $2, $3)
RETURNING id, sender_id, recipient_id, content, read_at, created_at
`

type CreateMessageParams struct {
	SenderID    sql.NullInt32 `json:"sender_id"`
	RecipientID sql.NullInt32 `json:"recipient_id"`
	Content     string        `json:"content"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage, arg.SenderID, arg.RecipientID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.RecipientID,
		&i.Content,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (user_id, title, content, type)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, title, content, type, read_at, created_at
`

type CreateNotificationParams struct {
	UserID  sql.NullInt32  `json:"user_id"`
	Title   string         `json:"title"`
	Content sql.NullString `json:"content"`
	Type    sql.NullString `json:"type"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.UserID,
		arg.Title,
		arg.Content,
		arg.Type,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.Type,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (name, slug, logo_url, settings)
VALUES ($1, $2, $3, $4)
RETURNING id, name, slug, logo_url, settings, created_at
`

type CreateOrganizationParams struct {
	Name     string                `json:"name"`
	Slug     string                `json:"slug"`
	LogoUrl  sql.NullString        `json:"logo_url"`
	Settings pqtype.NullRawMessage `json:"settings"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganization,
		arg.Name,
		arg.Slug,
		arg.LogoUrl,
		arg.Settings,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.Settings,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (name, description, owner_id, org_id, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, owner_id, org_id, status, created_at
`

type CreateProjectParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	OwnerID     sql.NullInt32  `json:"owner_id"`
	OrgID       sql.NullInt32  `json:"org_id"`
	Status      sql.NullString `json:"status"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Name,
		arg.Description,
		arg.OwnerID,
		arg.OrgID,
		arg.Status,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.OwnerID,
		&i.OrgID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (project_id, title, description, assignee_id, status, due_date)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, project_id, title, description, assignee_id, status, due_date, created_at
`

type CreateTaskParams struct {
	ProjectID   sql.NullInt32  `json:"project_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	AssigneeID  sql.NullInt32  `json:"assignee_id"`
	Status      sql.NullString `json:"status"`
	DueDate     sql.NullTime   `json:"due_date"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.ProjectID,
		arg.Title,
		arg.Description,
		arg.AssigneeID,
		arg.Status,
		arg.DueDate,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.AssigneeID,
		&i.Status,
		&i.DueDate,
		&i.CreatedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (org_id, name, description)
VALUES ($1, $2, $3)
RETURNING id, org_id, name, description, created_at
`

type CreateTeamParams struct {
	OrgID       sql.NullInt32  `json:"org_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, createTeam, arg.OrgID, arg.Name, arg.Description)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, name, hashed_password, avatar_url)
VALUES ($1, $2, $3, $4)
RETURNING id, email, name, hashed_password, avatar_url, created_at, updated_at
`

type CreateUserParams struct {
	Email          string         `json:"email"`
	Name           sql.NullString `json:"name"`
	HashedPassword sql.NullString `json:"hashed_password"`
	AvatarUrl      sql.NullString `json:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.Name,
		arg.HashedPassword,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.HashedPassword,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActivityFeed = `-- name: GetActivityFeed :many
SELECT af.id, af.actor_id, af.action, af.target_type, af.target_id, af.org_id, af.created_at, u.name as actor_name, u.avatar_url as actor_avatar
FROM activity_feed af
JOIN users u ON u.id = af.actor_id
WHERE af.org_id = $1
ORDER BY af.created_at DESC
LIMIT $2
`

type GetActivityFeedParams struct {
	OrgID sql.NullInt32 `json:"org_id"`
	Limit int32         `json:"limit"`
}

type GetActivityFeedRow struct {
	ID          int32          `json:"id"`
	ActorID     sql.NullInt32  `json:"actor_id"`
	Action      string         `json:"action"`
	TargetType  sql.NullString `json:"target_type"`
	TargetID    sql.NullInt32  `json:"target_id"`
	OrgID       sql.NullInt32  `json:"org_id"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	ActorName   sql.NullString `json:"actor_name"`
	ActorAvatar sql.NullString `json:"actor_avatar"`
}

func (q *Queries) GetActivityFeed(ctx context.Context, arg GetActivityFeedParams) ([]GetActivityFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityFeed, arg.OrgID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivityFeedRow
	for rows.Next() {
		var i GetActivityFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.ActorID,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.OrgID,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeatureFlag = `-- name: GetFeatureFlag :one
SELECT name, description, enabled, rollout_percentage, created_at FROM feature_flags WHERE name = $1
`

func (q *Queries) GetFeatureFlag(ctx context.Context, name string) (FeatureFlag, error) {
	row := q.db.QueryRowContext(ctx, getFeatureFlag, name)
	var i FeatureFlag
	err := row.Scan(
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.RolloutPercentage,
		&i.CreatedAt,
	)
	return i, err
}

const getOrganizationBySlug = `-- name: GetOrganizationBySlug :one
SELECT id, name, slug, logo_url, settings, created_at FROM organizations WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetOrganizationBySlug(ctx context.Context, slug string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationBySlug, slug)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.Settings,
		&i.CreatedAt,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT u.id, u.email, u.name, u.hashed_password, u.avatar_url, u.created_at, u.updated_at, tm.role as team_role
FROM team_members tm
JOIN users u ON u.id = tm.user_id
WHERE tm.team_id = $1
`

type GetTeamMembersRow struct {
	ID             int32          `json:"id"`
	Email          string         `json:"email"`
	Name           sql.NullString `json:"name"`
	HashedPassword sql.NullString `json:"hashed_password"`
	AvatarUrl      sql.NullString `json:"avatar_url"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	TeamRole       string         `json:"team_role"`
}

func (q *Queries) GetTeamMembers(ctx context.Context, teamID int32) ([]GetTeamMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersRow
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.HashedPassword,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TeamRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadMessageCount = `-- name: GetUnreadMessageCount :one
SELECT COUNT(*)
FROM messages
WHERE recipient_id = $1 AND read_at IS NULL
`

func (q *Queries) GetUnreadMessageCount(ctx context.Context, recipientID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadMessageCount, recipientID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnreadNotifications = `-- name: GetUnreadNotifications :many
SELECT id, user_id, title, content, type, read_at, created_at
FROM notifications
WHERE user_id = $1 AND read_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetUnreadNotifications(ctx context.Context, userID sql.NullInt32) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.Type,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, hashed_password, avatar_url, created_at, updated_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.HashedPassword,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, name, hashed_password, avatar_url, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.HashedPassword,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProjectsByOrg = `-- name: ListProjectsByOrg :many
SELECT p.id, p.name, p.description, p.owner_id, p.org_id, p.status, p.created_at, u.name as owner_name
FROM projects p
JOIN users u ON u.id = p.owner_id
WHERE p.org_id = $1
ORDER BY p.created_at DESC
`

type ListProjectsByOrgRow struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	OwnerID     sql.NullInt32  `json:"owner_id"`
	OrgID       sql.NullInt32  `json:"org_id"`
	Status      sql.NullString `json:"status"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	OwnerName   sql.NullString `json:"owner_name"`
}

func (q *Queries) ListProjectsByOrg(ctx context.Context, orgID sql.NullInt32) ([]ListProjectsByOrgRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsByOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsByOrgRow
	for rows.Next() {
		var i ListProjectsByOrgRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.OwnerID,
			&i.OrgID,
			&i.Status,
			&i.CreatedAt,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByProject = `-- name: ListTasksByProject :many
SELECT t.id, t.project_id, t.title, t.description, t.assignee_id, t.status, t.due_date, t.created_at, u.name as assignee_name
FROM tasks t
LEFT JOIN users u ON u.id = t.assignee_id
WHERE t.project_id = $1
ORDER BY t.due_date ASC NULLS LAST
`

type ListTasksByProjectRow struct {
	ID           int32          `json:"id"`
	ProjectID    sql.NullInt32  `json:"project_id"`
	Title        string         `json:"title"`
	Description  sql.NullString `json:"description"`
	AssigneeID   sql.NullInt32  `json:"assignee_id"`
	Status       sql.NullString `json:"status"`
	DueDate      sql.NullTime   `json:"due_date"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	AssigneeName sql.NullString `json:"assignee_name"`
}

func (q *Queries) ListTasksByProject(ctx context.Context, projectID sql.NullInt32) ([]ListTasksByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksByProjectRow
	for rows.Next() {
		var i ListTasksByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.AssigneeID,
			&i.Status,
			&i.DueDate,
			&i.CreatedAt,
			&i.AssigneeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByOrganization = `-- name: ListUsersByOrganization :many
SELECT DISTINCT u.id, u.email, u.name, u.hashed_password, u.avatar_url, u.created_at, u.updated_at
FROM users u
JOIN team_members tm ON tm.user_id = u.id
JOIN teams t ON t.id = tm.team_id
WHERE t.org_id = $1
`

func (q *Queries) ListUsersByOrganization(ctx context.Context, orgID sql.NullInt32) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByOrganization, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.HashedPassword,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAuditEvent = `-- name: LogAuditEvent :one
INSERT INTO audit_logs (user_id, action, entity_type, entity_id, metadata)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, action, entity_type, entity_id, metadata, created_at
`

type LogAuditEventParams struct {
	UserID     sql.NullInt32         `json:"user_id"`
	Action     string                `json:"action"`
	EntityType string                `json:"entity_type"`
	EntityID   int32                 `json:"entity_id"`
	Metadata   pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) LogAuditEvent(ctx context.Context, arg LogAuditEventParams) (AuditLog, error) {
	row := q.db.QueryRowContext(ctx, logAuditEvent,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.Metadata,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const markMessageAsRead = `-- name: MarkMessageAsRead :exec
UPDATE messages
SET read_at = NOW()
WHERE id = $1 AND recipient_id = $2
`

type MarkMessageAsReadParams struct {
	ID          int32         `json:"id"`
	RecipientID sql.NullInt32 `json:"recipient_id"`
}

func (q *Queries) MarkMessageAsRead(ctx context.Context, arg MarkMessageAsReadParams) error {
	_, err := q.db.ExecContext(ctx, markMessageAsRead, arg.ID, arg.RecipientID)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, title, description, assignee_id, status, due_date, created_at
`

type UpdateTaskStatusParams struct {
	ID     int32          `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTaskStatus, arg.ID, arg.Status)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.AssigneeID,
		&i.Status,
		&i.DueDate,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name = COALESCE($2, name),
    email = COALESCE($3, email),
    avatar_url = COALESCE($4, avatar_url),
    updated_at = NOW()
WHERE id = $1
RETURNING id, email, name, hashed_password, avatar_url, created_at, updated_at
`

type UpdateUserParams struct {
	ID        int32          `json:"id"`
	Name      sql.NullString `json:"name"`
	Email     string         `json:"email"`
	AvatarUrl sql.NullString `json:"avatar_url"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.HashedPassword,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertFeatureFlag = `-- name: UpsertFeatureFlag :one
INSERT INTO feature_flags (name, description, enabled, rollout_percentage)
VALUES ($1, $2, $3, $4)
ON CONFLICT (name) DO UPDATE
SET description = EXCLUDED.description,
    enabled = EXCLUDED.enabled,
    rollout_percentage = EXCLUDED.rollout_percentage,
    created_at = NOW()
RETURNING name, description, enabled, rollout_percentage, created_at
`

type UpsertFeatureFlagParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Enabled           sql.NullBool   `json:"enabled"`
	RolloutPercentage sql.NullInt32  `json:"rollout_percentage"`
}

func (q *Queries) UpsertFeatureFlag(ctx context.Context, arg UpsertFeatureFlagParams) (FeatureFlag, error) {
	row := q.db.QueryRowContext(ctx, upsertFeatureFlag,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.RolloutPercentage,
	)
	var i FeatureFlag
	err := row.Scan(
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.RolloutPercentage,
		&i.CreatedAt,
	)
	return i, err
}
